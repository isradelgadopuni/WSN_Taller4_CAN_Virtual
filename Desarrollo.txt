# PARTE 1

Paso 1 - SocketCAN: Instalar SocketCAN 
	
	Logrado con el Dockerfile

Paso 2 â€” Virtual CAN driver (vcan):

	# 1ï¸âƒ£  Cargar el mÃ³dulo del kernel para interfaces CAN virtuales (solo este en el host)
	sudo modprobe vcan

	# 2ï¸âƒ£  Crear la interfaz virtual llamada vcan0
	ip link add dev vcan0 type vcan

	# 3ï¸âƒ£  Activarla (pasar de DOWN a UP)
	ip link set up vcan0

	# 4ï¸âƒ£  Verificar que exista y estÃ© activa
	ip link show vcan0

Paso 3 - RevisiÃ³n de las herramientas de SocketCAN:

	a) La herramienta que genera trÃ¡fico es cangen, y la que monitorea trÃ¡fico es candump.

	b) candump muestra y registra todas las tramas completas del bus, mientras que cansniffer organiza las tramas por ID y resalta las diferencias en los datos, facilitando la interpretaciÃ³n de cambios en tiempo real.
	
Paso 4 - Generar tramas CAN aleatorias y monitorearlas:
ip
	En una terminal:

	candump vcan0

	En otra terminal:
	
	cangen vcan0
	
	CÃ³mo leer cada lÃ­nea de candump

	Ejemplo tÃ­pico:

	(0123.456789)  vcan0  123   [8]  11 22 33 44 55 66 77 88


	(0123.456789) â†’ timestamp (segundos.micros) de captura. Solo aparece si activas timestamp; si no, se omite.

	vcan0 â†’ interfaz CAN por la que se recibiÃ³ la trama (tu bus virtual).

	123 â†’ ID de la trama en hexadecimal.

	11 bits (0x000â€“0x7FF) = trama estÃ¡ndar.

	Si fuera extendida (29 bits), verÃ­as un ID > 0x7FF o un indicador segÃºn el formato usado.

	[8] â†’ DLC (Data Length Code): nÃºmero de bytes de datos (0â€“8 en CAN clÃ¡sico).

	11 22 33 44 55 66 77 88 â†’ payload en hex: son los bytes crudos tal como viajaron en el bus (sin interpretaciÃ³n).

	Cada par hex representa 1 byte (0x00â€“0xFF).

	El significado (enteros, flags, ASCII, escalas) depende del protocolo/DBC.

	Variantes y banderas que puedes encontrar

	RTR (Remote Transmission Request): trama de peticiÃ³n sin datos Ãºtiles; el DLC indica cuÃ¡ntos bytes espera, pero el payload va vacÃ­o.

	EstÃ¡ndar vs extendida: 11 bits vs 29 bits (extendida puede mostrarse con un flag/indicador segÃºn la versiÃ³n de candump).

	Errores: si hubiera frames de error, candump puede marcarlos como tales (no es lo habitual en vcan salvo que los fuerces).

	Â¿QuÃ© significan â€œlos valores hexadecimalesâ€?

	Son datos brutos. Por ejemplo, si envÃ­as la cadena ASCII â€œholamundoâ€, el payload tÃ­pico serÃ­a:
	68 6F 6C 61 6D 75 6E 64 6F
	(porque â€˜hâ€™=0x68, â€˜oâ€™=0x6F, etc.).

	Si el mensaje codifica sensores (velocidad, rpm, etc.), esos bytes pueden ser enteros, flags o campos bit a bit. Sin un DBC o especificaciÃ³n, candump solo te muestra los bytes crudos.

	QuÃ© deberÃ­as haber observado con cangen + candump

	IDs cambiando (aleatorios por defecto).

	DLC variando entre 0 y 8.

	Payload variando en cada trama (bytes hex distintos).

	Timestamps incrementÃ¡ndose conforme llegan las tramas.

Paso 5 â€” Guardar tramas en un archivo .log:

	# Terminal A â€” Registrar el trÃ¡fico en un .log
	
	candump -l vcan0
	
	# Terminal B â€” Generar trÃ¡fico mientras registras

	cangen vcan0
	
Paso 6 - Reproducir las tramas guardadas en el archivo .log:

	canplayer -I candump-YYYY-MM-DD_HH:MM:SS.log

Paso 7 - Generar una trama CAN especÃ­fica:

	ğŸ§© ConversiÃ³n de â€œholamundoâ€ a hexadecimal

	Cada carÃ¡cter ASCII tiene un valor hexadecimal:

	Caracter	Hex
	h	68
	o	6F
	l	6C
	a	61
	m	6D
	u	75
	n	6E
	d	64
	o	6F

	CAN clÃ¡sico permite mÃ¡ximo 8 bytes de datos, por lo que se enviarÃ¡n los primeros 8:
	68 6F 6C 61 6D 75 6E 64 (corresponde a â€œholamundâ€).

	Terminal 1 â€“ Monitorear el bus
	
	candump vcan0

	Terminal 2 â€“ Enviar la trama (completa)
	
	cansend vcan0 012#686F6C616D756E646F

Paso 8 - Generar varias tramas CAN y organizar la salida por ID y datos cambiantes:

	Terminal 1 â€” Monitor con cansniffer
	
	cansniffer vcan0
	
	Terminal 2 â€” Generar trÃ¡fico

	cangen vcan0
	
	Usando cansniffer, se observÃ³ una visualizaciÃ³n organizada de las tramas CAN agrupadas por ID. Los campos de datos que varÃ­an entre tramas se destacan en tiempo real, lo que facilita identificar quÃ© bytes cambian y analizar el comportamiento del bus.
	
	
Paso 9 - Trama standard y extendida. Captura con Wireshark para mostrar los cambios. 

	Terminal 1 â€” Capturar en .pcap

	Ejecuta dentro del contenedor:

	umask 0002 && tshark -i vcan0 -w - > /root/capturas/captura_can_bus.pcap
	
	Terminal 2 â€” Generar trÃ¡fico CAN

	En otra terminal dentro del mismo contenedor, genera tramas:

	# Standard	
	
	cangen vcan0 -g 10 -I 123 -L 8
	
	# Trama extendida
	
	cansend vcan0 1ABCDEEF#1122334455667788


	ğŸ§  Conceptos clave
	Tipo de trama	Identificador	Longitud del ID	Campo â€œIDEâ€	Uso tÃ­pico
	EstÃ¡ndar	0x000 â€“ 0x7FF	11 bits	0 (dominante)	CAN 2.0A, automotriz clÃ¡sico
	Extendida	0x00000000 â€“ 0x1FFFFFFF	29 bits	1 (recesivo)	CAN 2.0B, mensajes con mayor segmentaciÃ³n
	ğŸ§© Diferencias estructurales visibles en Wireshark

	Abre el archivo captura_can_bus.pcap en Wireshark y compara las tramas con ID 0x123 y 0x1ABCDEEF:

	Campo	Trama estÃ¡ndar (0x123)	Trama extendida (0x1ABCDEEF)
	Identifier	11-bit (0x123)	29-bit (0x1ABCDEEF)
	IDE flag	0 (Standard frame)	1 (Extended frame)
	RTR	0 = Data frame	0 = Data frame (igual)
	DLC	8	8
	Data bytes	8 bytes hex	8 bytes hex (mismo formato)

	En la columna de â€œCAN Frameâ€ Wireshark mostrarÃ¡ algo como:

	Frame ID: 0x123 (Standard)
	Frame ID: 0x1ABCDEEF (Extended)
	IDE: Standard/Extended frame format flag


	El Ãºnico cambio estructural es el campo â€œIDEâ€ (Identifier Extension Bit) dentro del â€œArbitration Fieldâ€,
	que indica si el ID ocupa 11 bits o 29 bits.
	Los campos SOF, RTR, DLC, Data, CRC se mantienen iguales en su funciÃ³n.

	ğŸ§© ConclusiÃ³n para tu informe

	Se generaron y analizaron tramas estÃ¡ndar (ID 0x123, 11 bits) y extendidas (ID 0x1ABCDEEF, 29 bits).
	En Wireshark se observÃ³ que ambas comparten la misma estructura general, diferenciÃ¡ndose Ãºnicamente en el campo IDE, que cambia de 0 a 1 para indicar formato extendido, y en la longitud del identificador (de 11 a 29 bits).
	Los campos de control (RTR, DLC) y los datos permanecen inalterados.

Paso 10 - Tramas Remote Transmission Request (RTR):

	Terminal 1 â€“ Monitorear
	
	umask 0002 && tshark -i vcan0 -w - > /root/capturas/captura_rtr.pcap

	Terminal 2 â€“ Enviar una RTR frame

	CAN RTR se envÃ­a con r (minÃºscula) despuÃ©s del ID:

	cansend vcan0 123#R

	Puedes indicar el nÃºmero de bytes esperados en la respuesta (DLC) asÃ­:

	cansend vcan0 123#R8
	
	ğŸ§  QuÃ© observarÃ¡s en Wireshark

	Abre la captura: Wireshark mostrarÃ¡ algo similar a:

	Frame ID: 0x123 (Standard frame)
	RTR: Remote request frame
	DLC: 8
	Data: <none>


	ğŸ”¹ El campo RTR cambia de 0 a 1.
	ğŸ”¹ El campo Data no contiene bytes.
	ğŸ”¹ El valor DLC se mantiene (indica cuÃ¡ntos bytes espera recibir, no cuÃ¡ntos contiene).

	âœ… ConclusiÃ³n para tu informe

	Se generÃ³ una trama CAN de tipo Remote Transmission Request (RTR) con ID 0x123.
	En Wireshark se observa que el bit RTR cambia a 1, lo que indica una peticiÃ³n de datos.
	El campo DLC indica el tamaÃ±o esperado del payload, pero el campo Data permanece vacÃ­o.
	Por ello, el â€œtamaÃ±o del payloadâ€ aparente varÃ­a: las tramas RTR no transportan datos, solo solicitan una respuesta del nodo correspondiente.
